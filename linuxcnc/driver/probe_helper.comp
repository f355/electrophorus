component probe_helper "switches probe input based on the selected tool";
description """This component is intended to help with probing routines.

COMBINING THE INPUTS

On machines equipped with both the tool setter on the bed and the spindle touch probe, combining those two inputs might
prove tricky.

Under normal operation, the tool setter input should be used for motion.probe-input, in order to measure
the tool length on Tx M6 commands. If we need to use the touch probe, its input should be used instead.

Combining the inputs with a simple boolean OR would generally work.

However, the touch probe usually has a certain amount of deflection (typically 0.01-0.03 mm) before it triggers,
so when we measure the probe length against the tool setter, and the probe spring is stronger
than that of the tool setter, the tool setter would trigger first and this deflection would not be accounted for.
Combining the inputs with AND would solve this, but it won't work for the previous use case.

This component solves that by changing the logic conditionally:

1. Under normal operation, both inputs (probe_helper.probe-in and probe_helper.tool-setter-in) are ORed and
   the result is fed into probe_helper.out.
2. When the following two conditions are met, the inputs are ANDed instead:
   * The active tool number (probe_helper.tool-number) is equal to the probe tool number in the library
     (probe_helper.probe-number);
   * The current X and Y machine coordinates (probe_helper.current-x and probe_helper.current-y) are within
     the rectangle centered on the tool setter (probe_helper.tool-setter-x and probe_helper.tool-setter-y) with
     the side equal to probe_helper.tool-setter-size.

The pin names assume that the tool setter is mounted vertically along the Z axis, however, that is not a requirement,
feel free to ignore the naming and use different axes for the coordinate inputs to accommodate the way your machine
is set up.

PROBE CRASH PROTECTION

This component also provides rudimentary probe crash protection: when either of the input signals triggers,
the current values of probe_helper.current-<axis> are latched to memory and the subsequent motion is tracked.
If the distance from the latched point gets greater than probe_helper.max-probing-distance, the probe_helper.probe-alarm
pin is set to TRUE, you can connect it to motion.feed-inhibit and/or motion.jog-inhibit. When both input signals are
set to FALSE, the latching is reset. If the alarm triggers, bring the machine to e-stop and back, that should allow you
to jog away from the dangerous direction.

CAUTION:
1. if you accidentally put a wrong tool in the spindle instead of the touch probe, or the touch probe is not working
   properly for some reason, you WILL crash the machine! Always check that the touch probe is powered and working,
   LinuxCNC GUIs typically have an LED in the interface that lights up when the probe is triggered.
2. Do not try to use the touch probe within the tool setter rectangle, you WILL break the probe.
3. The rotary axis movements are not considered in the crash protection. It is very rare to probe rotation, but if you
   do, please don't rely on this component.

""";

examples """
loadrt probe_helper
addf probe-helper servo-thread

# 10mm rectangle centered on (-10, -10)
setp probe-helper.tool-setter-x -10.0
setp probe-helper.tool-setter-y -10.0
setp probe-helper.tool-setter-size 10.0
setp probe-helper.probe-number 99
setp probe-helper.max-probing-distance 1.0

net probe.helper.probe-in <your touch probe pin> => probe-helper.probe-in
net probe.helper.tool-setter-in <your tool setter pin> => probe-helper.tool-setter-in
net probe.helper.probe-tool-number iocontrol.0.tool-number => probe-helper.tool-number
net probe.helper.current-x joint.0.pos-fb => probe-helper.current-x
net probe.helper.current-y joint.1.pos-fb => probe-helper.current-y
net probe.helper.current-z joint.2.pos-fb => probe-helper.current-z
net probe.helper.out probe-helper.out => motion.probe-input
net probe.helper.alarm probe-helper.alarm => motion.feed-inhibit => motion.jog-inhibit

""";

author "Konstantin Tcepliaev <f355@f355.org>";
license "GPL";

option singleton yes;

param rw s32 probe-number "Touch probe tool number in the tool library";
param rw float max-probing-distance "Maximum travel distance allowed when probing is active";
param rw float tool-setter-x "X machine coordinate of the tool setter center";
param rw float tool-setter-y "Y machine coordinate of the tool setter center";
param rw float tool-setter-size "XY size of the tool setter in machine units";

pin in s32 tool-number "Current/active tool number";
pin in float current-x "Current X machine coordinate";
pin in float current-y "Current Y machine coordinate";
pin in float current-z "Current Z machine coordinate";
pin in bit probe-in "Touch probe input";
pin in bit tool-setter-in "Tool setter input";
pin out bit out_ "The output value";
pin out bit alarm "The probe or the tool setter has exceeded maximium travel, bad things are about to happen";

variable float trigger_x;
variable float trigger_y;
variable float trigger_z;
variable bool probing;

function _;

;;

#include "rtapi_math.h"

FUNCTION(_) {
  bool input_active = probe_in || tool_setter_in;
  if (!input_active) {
    // both inputs are inactive, reset the state/outputs and bail out
    probing = false;
    alarm = false;
    out_ = false;
    return;
  }

  float x = current_x;
  float y = current_y;
  float z = current_z;
  float r = tool_setter_size * 0.5;
  if ((x > tool_setter_x - r) && (x < tool_setter_x + r) && (y > tool_setter_y - r) && (y < tool_setter_y + r)) {
    // we're near the tool setter, AND the inputs
    out_ = probe_in && tool_setter_in;
  } else {
    out_ = input_active;
  }

  if (!probing) {
    // probing just started, latch the coordinates
    probing = true;
    trigger_x = x;
    trigger_y = y;
    trigger_z = z;
    return;
  }

  if (max_probing_distance < sqrt(
    (x - trigger_x) * (x - trigger_x) +
    (y - trigger_y) * (y - trigger_y) +
    (z - trigger_z) * (z - trigger_z)
  )) {
    alarm = true;
  }
}
